using System;
using Map;
using UnityEngine;
using Random = UnityEngine.Random;

namespace AI {
    public class AIBehaviour {
        private static float MINIMUM_PRECISION_ANGLE = 3.0f;
        private static float APPROXIMATION_FRONT_COEFFICIENT = 0.25f;
        private static float MAX_SQUARE_ATTACKING_RANGE = (float)Math.Pow(3.0f, 2);
        private static float MAX_SQUARE_POI_DISTANCE = (float)Math.Pow(0.15f * GameGrid.gridBoxSize, 2);
        private static float MAX_SQUARE_DETECTION_RANGE = (float)Math.Pow(3.5f * GameGrid.gridBoxSize, 2);
        private static float MAX_SQUARE_APPROACHING_RANGE = (float)Math.Pow(2f * GameGrid.gridBoxSize, 2);
        private static int PATH_EXPLORATION_RANGE = 6;

        private static float MAX_WAITING_COOLDOWN_TIME = 0.1f;
        private static float MAX_WANDERING_COOLDOWN_TIME = 5f;
        private static float MAX_FINDING_COOLDOWN_TIME = 3f;
        private static float MAX_APPROACHING_COOLDOWN_TIME = 0.5f; //0.4f; // watch out if too greedy on resources
        
        private ActionState _actionState;
        private MovementRotationState _movementRotationState;
        private MovementTranslationState _movementTranslationState;
        private readonly GameObject _player;
        private readonly Transform _current;
        private Vector3 _pointOfInterest;
        private Transform _playerTransform;
        private float _actionCooldownTime;
        private float _reflexCooldownTime;
        private GameGrid gameGrid;
        private bool isPlayerAlive;
        
        public bool isAttacking;

        public AIBehaviour(GameObject gameObject, GameGrid grid) {
            _current = gameObject.transform;
            gameGrid = grid;
            _player = GameObject.FindGameObjectWithTag(Global.PLAYER_TAG);
            _playerTransform = _player.transform;
            isPlayerAlive = true;
            
            changeActionState(ActionState.WAITING);
            _movementRotationState = MovementRotationState.NONE;
            _movementTranslationState = MovementTranslationState.NONE;
            _actionCooldownTime = 0f;
            _reflexCooldownTime = 0f;
            _pointOfInterest = _current.position;
            isAttacking = false;
        }
        
        // update is called once per frame
        public void update() {
            var timelapse = Time.deltaTime;
            playStateAction(timelapse);
            updateMovementState();
        }

        public MovementRotationState getRotationState() {
            return _movementRotationState;
        }

        public MovementTranslationState getTranslationState() {
            return _movementTranslationState;
        }

        private void updateMovementState() {
            if (_actionState == ActionState.WANDERING || _actionState == ActionState.FINDING) {
                movementAdjustmentToObjective(_pointOfInterest);
            } else if (_actionState == ActionState.APPROACHING || _actionState == ActionState.ATTACKING) {
                // TODO: change movement if attacking generate a new collider
                movementAdjustmentToObjective(_playerTransform.position);
            }
        }

        private void playStateAction(float timelapse) {
            _actionCooldownTime -= timelapse;
            if (_actionCooldownTime > 0) {
                resumeStateAction();
            } else {
                completeStateAction();
            }
        }

        private void resumeStateAction() {
            switch (_actionState) {
                case ActionState.WANDERING:
                    resumeWanderingAction();
                    break;
                case ActionState.FINDING:
                    resumeFindingAction();
                    break;
                case ActionState.APPROACHING:
                    resumeApproachingAction();
                    break;
                case ActionState.ATTACKING:
                    resumeAttackingAction();
                    break;
            }
        }

        // resume action when AI is wandering between points of interests, looking for an enemy
        private void resumeWanderingAction() {
            if (isWithinRangeOfPOI(MAX_SQUARE_POI_DISTANCE)) {
                _actionCooldownTime = 0f;
            }
        }

        private void resumeFindingAction() {
            if (isWithinRangeOfPOI(MAX_SQUARE_POI_DISTANCE)) {
                _actionCooldownTime = 0f;
            }
        }

        private void resumeApproachingAction() {
            if (!isWithinRangeOfPlayer(MAX_SQUARE_APPROACHING_RANGE)) {
                _actionCooldownTime = 0f;
            }
            // removed because attacks are generated by collision for now
            /* else if (isWithinRangeOfPlayer(MAX_ATTACKING_RANGE)) {
                _actionCooldownTime = 0f;
            }*/
        }

        private void resumeAttackingAction() {
            if (isWithinRangeOfPlayer(MAX_SQUARE_ATTACKING_RANGE)) {
                _actionCooldownTime = 0f;
            }
        }

        private void completeStateAction() {
            switch (_actionState) {
                case ActionState.WAITING:
                    completeWaitingAction();
                    break;
                case ActionState.WANDERING:
                    completeWanderingAction();
                    break;
                case ActionState.FINDING:
                    completeFindingAction();
                    break;
                case ActionState.APPROACHING:
                    completeApproachAction();
                    break;
                case ActionState.ATTACKING:
                    completeAttackingAction();
                    break;
            }
        }

        private void completeWaitingAction() {
            // skip if player is dead
            if (isPlayerAlive) {
                if (isWithinRangeOfPlayer(MAX_SQUARE_DETECTION_RANGE)
                    && pathDistanceToPlayer() <= PATH_EXPLORATION_RANGE) {
                    initializeFindingState();
                    return;
                }
            }
            initializeWanderingState();
        }

        private void completeWanderingAction() {
            initializeWaitingState();
        }

        private void completeFindingAction() {
            // check if player in euclidian range
            if (isWithinRangeOfPlayer(MAX_SQUARE_DETECTION_RANGE)) {
                if (isWithinLineOfSight()) {
                    initializeApproachingState();
                    return;
                }
                // check if in range following a path
                if (pathDistanceToPlayer() <= PATH_EXPLORATION_RANGE) {
                    initializeFindingState();
                    return;
                }
            }
            initializeWaitingState();
            
        }

        private void completeApproachAction() {
            /*
            if (isWithinRangeOfPlayer(MIN_SQUARE_APPROACHING_RANGE)) {
                initializeAttackingState();
                return;
            }
             */
            if (isWithinRangeOfPlayer(MAX_SQUARE_APPROACHING_RANGE)) {
                if (isWithinLineOfSight()) {
                    initializeApproachingState();
                    return;
                }
            }
            
            initializeFindingState();
        }

        private void completeAttackingAction() {
            var targetDistance = Vector3.Distance(_current.position, _playerTransform.position);
            if (targetDistance > MAX_SQUARE_APPROACHING_RANGE) {
                isAttacking = false;
                changeActionState(ActionState.WAITING);
                _actionCooldownTime = Random.Range(0.5f, 1f);
            } else if (targetDistance > MAX_SQUARE_ATTACKING_RANGE) {
                isAttacking = false;
                changeActionState(ActionState.APPROACHING);
            } else {
                _actionCooldownTime = 1.0f;
            }
        }

        private void initializeWaitingState() {
            _actionCooldownTime = MAX_WAITING_COOLDOWN_TIME;
            changeActionState(ActionState.WAITING);
        }

        private void initializeWanderingState() {
            _actionCooldownTime = MAX_WANDERING_COOLDOWN_TIME;
            var currentPos = _current.position;
            _pointOfInterest = gameGrid.getRandomAdjacent(currentPos.x, currentPos.y, currentPos.z);
            //Debug.Log("Going from " + currentPos + " to " + _pointOfInterest);
            changeActionState(ActionState.WANDERING);
        }

        private void initializeFindingState() {
            _actionCooldownTime = MAX_FINDING_COOLDOWN_TIME;
            _pointOfInterest = nextPositionToPlayer();
            changeActionState(ActionState.FINDING);
        }

        private void initializeApproachingState() {
            _actionCooldownTime = MAX_APPROACHING_COOLDOWN_TIME;
            changeActionState(ActionState.APPROACHING);
        }

        private bool isWithinRangeOfPOI(float squareRange) {
            var currentPos = _current.position;
            return Math.Pow(currentPos.x - _pointOfInterest.x, 2) +
                   Math.Pow(currentPos.z - _pointOfInterest.z, 2)
                   < squareRange;
        }

        private bool isWithinRangeOfPlayer(float squareRange) {
            var currentPos = _current.position;
            var playerPos = _playerTransform.position;
            return Math.Pow(currentPos.x - playerPos.x, 2) +
                   Math.Pow(currentPos.z - playerPos.z, 2)
                   < squareRange;
        }

        private Vector3 nextPositionToPlayer() {
            var currentPos = _current.position;
            var targetPos = _playerTransform.position;
            var currentIndex = gameGrid.realWorldCoordToIndex(currentPos.x, currentPos.z);
            var targetIndex = gameGrid.realWorldCoordToIndex(targetPos.x, targetPos.z);
            return gameGrid.indexToRealWorldCoord(gameGrid.getNextToIndex(currentIndex, targetIndex), currentPos.y);
        }

        private void movementAdjustmentToObjective(Vector3 objective) {
            var angle = alignmentToObjective(objective);
            translationToObjective(objective, angle);
        }

        private double alignmentToObjective(Vector3 objective) {
            var currentPosition = _current.position;
            var relativeAngle = Util.angleBetweenVec(
                currentPosition.x,
                objective.x,
                currentPosition.z,
                objective.z);
            relativeAngle -= _current.rotation.eulerAngles.y;
            if (relativeAngle < -180) {
                relativeAngle += 360;
            } else if (relativeAngle > 180) {
                relativeAngle -= 360;
            }
            if (_reflexCooldownTime > 0) {
                _movementRotationState = MovementRotationState.NONE;
            } else if (relativeAngle > MINIMUM_PRECISION_ANGLE / 2) {
                _movementRotationState = MovementRotationState.LEFT;
            } else if (relativeAngle < -MINIMUM_PRECISION_ANGLE / 2) {
                _movementRotationState = MovementRotationState.RIGHT;
            } else {
                _movementRotationState = MovementRotationState.NONE;
            }
            return relativeAngle;
        }

        private void translationToObjective(Vector3 objective, double relativeAngle) {
            if (Math.Abs(relativeAngle) > 45) {
                _movementTranslationState = MovementTranslationState.SLOW;
            } else {
                _movementTranslationState = MovementTranslationState.FORWARD;
            }
        }

        private void changeActionState(ActionState newState) {
            //Debug.Log("Changing to " + newState + " state");
            _actionState = newState;
        }

        public void removePlayer() {
            isPlayerAlive = false;
            if (_actionState != ActionState.WAITING && _actionState != ActionState.WANDERING) {
                initializeWaitingState();
            }
        }

        private int pathDistanceToPlayer() {
            var currentPosition = _current.position;
            var playerPosition = _playerTransform.position;
            var mapIndex = gameGrid.realWorldCoordToIndex(currentPosition.x, currentPosition.z);
            var playerIndex = gameGrid.realWorldCoordToIndex(playerPosition.x, playerPosition.z);

            return gameGrid.getIndexDistance(mapIndex, playerIndex);
        }

        private bool isWithinLineOfSight() {
            var currentPos = _current.position;
            var playerPos = _playerTransform.position;

            var direction = playerPos - currentPos;
            var ry = new Ray(currentPos, direction);

            var hits = Physics.RaycastAll(ry, direction.magnitude);
            //Debug.DrawRay (currentPos, direction, Color.red, 1.0f);

            return hits.Length == 0;
        }
    }
}
